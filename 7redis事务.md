## 事务的基础概念  
  
关于事务最常见的例子就是银行转账，A 账户给 B 账户转账一个亿 (T1)，买一块地盖房子。在这种交易的过程中，有几个问题值得思考：  
- 如何同时保证上述交易中，A账户总金额减少一个亿，B账户总金额增加一个亿？ A  
- A账户如果同时在和C账户交易(T2)，如何让这两笔交易互不影响？ I  
- 如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？ D  
- 如何在支持大量交易的同时，保证数据的合法性(没有钱凭空产生或消失) ？ C  

要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是事务诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性（**ACID**）。
![](./assets/re6.png)

**（1）原子性（Atomicity）: 事务要么全部完成，要么全部取消。 如果事务崩溃，状态回到事务之前（事务回滚）。**
确保不管交易过程中发生了什么意外状况（服务器崩溃、网络中断等），不能出现A账户少了一个亿，但B账户没到帐，或者A账户没变，但B账户却凭空收到一个亿（数据不一致）。A和B账户的金额变动要么同时成功，要么同时失败(保持原状)。

**（2）隔离性（Isolation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。**
如果A在转账1亿给B（T1），同时C又在转账3亿给A（T2），不管T1和T2谁先执行完毕，最终结果必须是A账户增加2亿，而不是3亿，B增加1亿，C减少3亿。

**（3）持久性（Durability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。**
确保如果 T1 刚刚提交，数据库就发生崩溃，T1执行的结果依然会保持在数据库中。

**（4）一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）才能写入数据库。**
确保钱不会在系统内凭空产生或消失， 依赖原子性和隔离性。

可以看出，原子性、隔离性、一致性的根本问题，是不同的事务同时对同一份数据(A账户)进行`写操作`(修改、删除、新增)，如果事务中都只是读数据的话，那么它们可以随意地同时进行，反正读到的数据都是一样的。

如果，几个互不知晓的事务在同时修改同一份数据，那么很容易出现，完成后的事务覆盖了前面的事务的结果，导致不一致。 事务在最终提交之前都有可能会回滚，撤销所有修改：
- 如果T1事务修改了A账户的数据，
- 这时T2事务读到了更新后的A账户数据，并进行下一步操作，
- 但此时T1事务却回滚了，撤销了对A账户的修改，
- 那么T2读取到的A账户数据就是非法的，这会导致数据不一致。
这些问题都是事务需要避免的

## redis中的事务
Redis 中提供了以下三个命令来处理事务：
```sh
# 标记一个事务块的开始
# 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行
MULTI

# 执行所有事务块内的命令。
EXEC

# 取消事务，放弃执行事务块内的所有命令。
DISCARD
```

eg：
```sh
127.0.0.1:6379> set jack 1000
OK
127.0.0.1:6379> set rose 1000
OK
# Jack 给 Rose 转账 500 块钱

# 开启事务
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby jack 500
QUEUED
127.0.0.1:6379(TX)> incrby rose 500
QUEUED
127.0.0.1:6379(TX)> exec # 提交事务
1) (integer) 500
2) (integer) 1500

127.0.0.1:6379> get jack
"500"
127.0.0.1:6379> get rose
"1500"
```

通过 `discard` 来放弃组队。注意是在 `[TX]` 队列当中，还没有执行 `exce` 命令之前，才有效。
```sh
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED

127.0.0.1:6379(TX)> discard
OK
```

## 事务中的错误处理

如果一个事务中的某个命令执行出错，Redis 会怎么处理呢？要回答这个问题，首先需要知道什么原因导致命令执行出错。

（1）语法错误。语法错误指命令不存在或命令参数的个数不对。比如：
```sh
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> set aa 151
QUEUED
127.0.0.1:6379(TX)> set key
(error) ERR wrong number of arguments for 'set' command

127.0.0.1:6379(TX)> exec
(error) EXECABORT Transaction discarded because of previous errors. # 事务因入队阶段（QUEUED）的错误而被主动放弃
```

跟在 MULTI 命令后执行了 3 个命令：
- 一个正确的命令，成功的加入了事务队列
- 另一条命令有语法错误
而只要有一个命令有语法错误，执行 `EXEC` 命令后 Redis 就会直接返回错误，连语法正确的命令也不会执行。

（2）运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前 Redis 是无法发现的，所以在事务里这样的命令是会被 Redis 接受并执行的。如果事务里的一条命令出现了运行错误，事务里其它的命令依然会继续执行，例如：
```sh
127.0.0.1:6379(TX)> set k1 v1
QUEUED
127.0.0.1:6379(TX)> decr k1 # k1 被设置为 String 类型，但进行运算操作
QUEUED
127.0.0.1:6379(TX)> set k2 v2
QUEUED
127.0.0.1:6379(TX)> exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
```
可见虽然 `decr k1` 出现了错误，但是 `set k2 v2` 依然执行了。

Redis 事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。

不过由于 Redis 不支持回滚功能，也使得 Redis 在事务上可以保持简洁和快速。此外回顾刚才提到的会导致事务执行失败的两种错误，其中语法错误完全可以在开发时找出并解决，另外如果能够很好的规划数据库的使用，是不会出现如命令与数据类型不匹配这样的运行时错误的。

**事务的两个阶段**：
- **入队阶段**（`MULTI` 后）：命令被缓存到队列中，此时仅检查语法错误。
- **执行阶段**（`EXEC` 后）：执行队列中的所有命令，此时可能发生运行时错误（如操作错误数据类型）。
**错误类型的影响**：
- **入队阶段的错误**（如语法错误）：整个事务会被标记为无效，执行 `EXEC` 时直接放弃事务。
- **执行阶段的错误**（如对字符串执行 `INCR`）：事务会继续执行，仅错误命令失败，其他命令仍生效。
## 事务中的 WATCH 命令

`WATCH` 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。

`WATCH` 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。

用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：
```sh
WATCH key1 key2 key3

# 取消 WATCH 命令对所有 key 的监视。
# 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。
UNWATCH
```

**当 `EXEC` 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消**。另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。

watch 监控账号余额的正常消费
```sh
127.0.0.1:6379> set balance 100
OK
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby balance 20
QUEUED
127.0.0.1:6379(TX)> decrby balance 30
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 80
2) (integer) 50
```


比如这个账号余额还绑定了老婆的支付宝，如果在我消费的时候，她也消费了，会怎么样呢？

我在超市选购商品，买水、买零食，这时候老婆在其他地方直接消费了 100，直接将余额刷爆了，此时余额不足。
```sh
127.0.0.1:6379> set balance 100
OK

# 当前我还在超市进行消费
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby balance 50
QUEUED
127.0.0.1:6379(TX)> decrby balance 6
QUEUED
# 此时还没有执行exec
```

```sh
# 另一个客户端，直接消费100
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby balance 100
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 0

127.0.0.1:6379> get balance
"0"
```
此时消费了100元，当前balance为0。然后完成，之前超时的消费进行提交执行`exec`

```sh
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby balance 50
QUEUED
127.0.0.1:6379(TX)> decrby balance 6
QUEUED
127.0.0.1:6379(TX)> exec
(nil)
```

使用无参数的 `UNWATCH` 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务，有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 `UNWATCH` 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。

**watch 指令，类似乐观锁**，事务提交时，如果 key 的值已被别的客户端改变，比如某个 list 已被别的客户端 push/pop 过了，整个事务队列都不会被执行。（当然也可以用 Redis 实现分布式锁来保证安全性，属于悲观锁）。

通过 watch 命令在事务执行之前监控了多个 keys，倘若在 watch 之后有任何 key 的值发生变化，exec 命令执行的事务都将被放弃，同时返回 Null 应答以通知调用者事务执行失败。

```sh
127.0.0.1:6379> set balance 100
OK
127.0.0.1:6379> watch balance
OK
127.0.0.1:6379> decrby balance 50 # WATCH 命令之后， EXEC 命令或 DISCARD 命令被执行了
(integer) 50
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decrby balance 10
QUEUED
127.0.0.1:6379(TX)> exec
(nil)
```

如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令被执行了的话，那么会自动取消 WATCH。

如果需要手动停止 WATCH 则可以可以使用 UNWATCH 命令，UNWATCH 命令会取消 WATCH 命令对所有 key 的监视。
## 事务冲突及解决方案(悲观锁，乐观锁) 

>1. 一个请求(用户)想购买 6 张票
>2. 一个请求(用户)想购买 5 张票
>3. 一个请求(用户)想购买 1 张票

![[assets/tran1.png]]
>一共只有10张票，但是并发开始，三个用户(三个请求)，买 6 张，买 5 张，买 1 张票的。同时进入购票系统，并发同时刻进入判断，都显示还剩10张票(还没有减)，最后执行减票，超卖了 2张票。

### “悲观锁”解决

![[assets/tran2.png]]

>1. 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。
>2. 这样别人/其他请求想要拿到这个数据都会被(block 锁上，因为被锁了就无法修改/拿到数据了)，只有直到在他前面的人拿到数据/修改数据后，将锁释放了，它才能将数据拿到。
>3. 悲观锁是锁设计理念 ，传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等等，都是在做操作之前先上锁(防止被其他的人/请求操作，修改了数据，导致数据不一致。)

### “乐观锁”解决

![[assets/tran3.png]]
  
> **乐观锁**
> 1. 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁。
> 2. 在更新的时候会判断一下，在此期间别人/请求是否有去更新了这个数据，可以使用版本号等机制。版本号机制：就是当这个数据被修改了，那么就会产生一个版本信息，如果这个版本信息，与你一开始对应，并应该获取的版本信息不一致，那么就修改失败/无法修改数据(或者说获取的版本信息不一致，拿不到该数据信息)
> 3. 乐观锁适用于多读的应用类型，这样可以提高吞吐量。 Redis 就是利用这种 check-and-set 机制实现事务的。
> 4. 乐观锁是锁设计理念。

## 参考链接

- [https://zhuanlan.zhihu.com/p/43493165](https://zhuanlan.zhihu.com/p/43493165)
- [https://xie.infoq.cn/article/84baa7fa9c2c3d3698a601def](https://xie.infoq.cn/article/84baa7fa9c2c3d3698a601def)
- https://rainbowsea.blog.csdn.net/article/details/145462239